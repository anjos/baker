#!/usr/bin/env python
# vim: set fileencoding=utf-8 :

"""Backs-up local folders on BackBlaze B2

Usage: %(prog)s [-v...] init [--overwrite] [--b2-account-id=<id>]
                [--b2-account-key=<key>] [--hostname=<name>]
                [--email --email-receiver=<name> [--email-receiver=<name> ...] --email-sender=<name> --email-username=<user> --email-password=<pwd> [--email-server=<host>] [--email-port=<port>]]
                <password> <config> [<config> ...]
       %(prog)s [-v...] update [--b2-account-id=<id>] [--b2-account-key=<key>]
                [--hostname=<name>] [--keep=<kept>]
                [--email --email-receiver=<name> [--email-receiver=<name> ...] --email-sender=<name> --email-username=<user> --email-password=<pwd> [--email-server=<host>] [--email-port=<port>]]
                [--run-daily-at=<hour>]
                <password> <config> [<config> ...]
       %(prog)s --help
       %(prog)s --version


Commands:

  init     Initializes (seeds or overwrites an existing one) with a new restic
           repository. Creates the first snapshot of the directory/directories
           to be backed-up. This procedure is not schedule-able as it can take
           long, but only needs to be done once per directory you want to
           back-up. Use it to initialize with the first snapshot, your new
           restic repository. If you set it up to do so, once the first
           snapshot is created, this app should send you an e-mail with the
           summary.
  update   Updates (or backs-up) continuously your local directory on the
           (remote) restic repository. After pre-seeding with the ``init``
           command above, you'll use this command (once a day or every N
           minutes) to keep your remote copy up-to-date with local changes. If
           set up to do so, this app will send you an e-mail everytime a new
           snapshot is created.


Arguments:

  <password>  Restic repository password. This value will be applied to all
              configurations defined after it.
  <config>    A double composed of a local directory and a repository,
              separated by a pipe '|' symbol. Example "/data|b2:data". This
              double indicates that the local directory "/data" will be
              backed-up on the BackBlaze B2 bucket called "data".


Options:
  -h, --help                   Shows this help message and exits
  -V, --version                Prints the version and exits
  -v, --verbose                Increases the output verbosity level. May be
                               used multiple times
  -b, --b2-account-id=<id>     The BackBlaze B2 account identifier. Must be
                               set if ``config`` uses a BackBlaze bucket as
                               repository
  -B, --b2-account-key=<key>   The BackBlaze B2 key to use to run the backup.
                               This key must have access to the specified
                               bucket. Must be set if ``config`` uses a
                               BackBlaze bucket as repository
  -H, --hostname=<name>        Use this name as hostname instead of the
                               environment's [default: %(hostname)s]
  -k, --keep=<kept>            A 6-tuple with integer values separated by a
                               pipe '|' symbol which indicate the number of
                               snapshots to keep for 'last', 'hourly', 'daily',
                               'weekly', 'monthly' and 'yearly' clean-ups. A
                               value of zero disables that option. Notice we
                               always prune the restic repository
                               [default: 0|0|7|9|13|3]
  -d, --run-daily-at=<hour>    Runs the back-up job daily at the specified
                               time [default: 1:00]
  -o, --overwrite              During initialization of a new restic
                               repository, overwrites contents of an existing
                               directory in case any exist. Use this option
                               with care.
  -e, --email                  If set, e-mail agents responsible every time
                               action occurs
  -r, --email-sender=<name>    Name/e-mail of the person that will appear as
                               the sender of the messages. This flag expects
                               entries in the format "John Doe <jd@ex.com>" or
                               "jd@ex.com"
  -r, --email-receiver=<name>  Name/e-mail of the person that will receive
                               messages generated by this application. Use this
                               option multiple times to indicate multiple
                               receivers of messages sent. This flag expects
                               entries in the format "John Doe <jd@ex.com>" or
                               "jd@ex.com".
  -u, --email-username=<name>  Username for the SMTP authentication and to be
                               used as the sender of e-mail messages
  -w, --email-password=<pwd>   Password for the SMTP authentication
  -S, --email-server=<host>    Name of the SMTP server to use for sending the
                               message [default: smtp.gmail.com]
  -P, --email-port=<port>      Port to use on the server [default: 587]


Examples:

  1. Runs the program and e-mails when done:

     $ %(prog)s -vv --email --email-username=me@gmail.com --password=secret

"""


import os
import sys
import textwrap
import traceback

import logging
logger = logging.getLogger(__name__)


def _send_message(subject, body, hostname, email):
  '''Sends an e-mail message or logs only'''

  from .reporter import Email

  sender = email.get('sender', 'nobody@example.com')
  receiver = email.get('receiver', ['nobody@example.com'])
  msg = Email(subject, body, hostname, sender, receiver)

  if email:
    msg.send(email['server'], email['port'], email['username'],
      email['password'])
  else:
    logger.info(msg.message())


def _send_success_email(action, configs, log, sizes, snapshots, hostname,
    email):
  '''Sends a success e-mail message or logs only'''

  body = '''\
    Hello,

    I just %(action)s the following repositories with no errors:

    %(repo)s
    Here is the snapshot information currently available:

    %(snapshot)s
    Here is some trace of the log for your reviewing pleasure:

    ## START OF LOG
    %(log)s
    ## END OF LOG

    That is it, have a good day!

    Your faithul robot
    '''

  import datetime
  from .reporter import human_time

  snapshots_log = ''
  for k in sorted(snapshots, key=lambda k: k['time']):
    since = (datetime.datetime.now() - k['time']).total_seconds()
    snapshots_log += '%s (%s ago) [%s] %s at %s\n' % \
        (k['time'].strftime('%Y-%m-%d %H:%M:%S'), human_time(since),
            k['short_id'], k['paths'][0], k['hostname'])

  repo_log = ''
  for k, (dire, repo) in enumerate(configs.items()):
    repo_log += '%s -> %s (%.2f Gb)\n' % \
        (dire, repo, sizes[k]/(1024.*1024.*1024.))

  subject = 'Successful %s of %s -> %s' % (action, dire, repo)
  body = textwrap.dedent(body)
  body = body % dict(
      action=action,
      repo=repo_log,
      snapshot=snapshots_log,
      log=log,
      )
  _send_message(subject, body, hostname, email)


def _send_error_email(action, configs, log, trace, hostname, email):
  '''Sends an error e-mail message or logs only'''

  body = '''\
    Hello,

    There has been an error during the %(action)s of:

    %(repo)s
    Here is the traceback information I collected:

    %(trace)s

    Here is some trace of the log to help you debugging:

    %(log)s

    That is it, have a good day!

    Your faithul robot
    '''

  repo_log = ''
  for k, (dire, repo) in enumerate(configs.items()):
    repo_log += '%s -> %s\n' % (dire, repo)

  subject = 'ERROR during %s' % (action,)
  body = textwrap.dedent(body)
  body = body % dict(
      action=action,
      repo=repo_log,
      log=log,
      trace=trace,
      )
  _send_message(subject, body, hostname, email)


def init(configs, password, overwrite, hostname, email, b2):
  '''Initializes a new set of repositories based on the configs'''

  if b2:
    os.environ.setdefault('B2_ACCOUNT_ID', b2['id'])
    os.environ.setdefault('B2_ACCOUNT_KEY', b2['key'])

  from .restic import init as _init
  from .restic import backup, snapshots

  log = ''
  sizes = []
  snaps = []

  try:

    for k, (dire, repo) in enumerate(configs.items()):

      if repo.startswith('b2:'): # BackBlaze B2 repository
        from .b2 import list_buckets, remove_bucket, authorize_account, \
            create_bucket
        log += authorize_account(b2['id'], b2['key'])
        if repo[3:] in list_buckets() and overwrite:
          remove_bucket(repo[3:])
        else:
          raise RuntimeError("BackBlaze B2 bucket `%s' already exists " \
              "and you did not pass --overwrite" % (repo))
        log += create_bucket(repo[3:])

      else:
        if os.path.exists(repo):
          if os.listdir(repo):
            if overwrite:
              logger.info("Removing directory `%s' on user request", repo)
              import shutil
              shutil.rmtree(repo)
              os.makedirs(repo)
            else:
              raise RuntimeError("Directory `%s' already exists " \
                  "and you did not pass --overwrite" % (repo))
        else:
          os.makedirs(repo)

      log += _init(repo, [], password)
      log += backup(dire, repo, [], hostname, [], password)

      snaps += snapshots(repo, [], hostname, password)

      if repo.startswith('b2:'):
        from .b2 import get_bucket
        info = get_bucket(repo[3:])
        sizes.append(0) #info['totalSize']
      else:
        from .utils import get_size
        sizes.append(get_size(repo))

    _send_success_email('initialized', configs, log, sizes, snaps, hostname,
        email)

  except Exception as e:
    _send_error_email('initialization', configs, log,
      traceback.format_exc(), hostname, email)

  return log, sizes, snaps


def update(configs, password, hostname, email, b2, keep, period):
  '''Runs a continuous job (never exists) for keeping the backup updated'''

  def job():
    '''The job that gets scheduled'''

    if b2:
      os.environ.setdefault('B2_ACCOUNT_ID', b2['id'])
      os.environ.setdefault('B2_ACCOUNT_KEY', b2['key'])

    from .restic import backup, forget, check, snapshots

    log = ''
    sizes = []
    snaps = []

    try:

      for dire, repo in configs.items():

        log += backup(
            directory=dire,
            repository=repo,
            global_options=[],
            hostname=hostname,
            backup_options=[],
            password=password,
            )

        log += forget(
            repository=repo,
            global_options=[],
            hostname=hostname,
            prune=True,
            keep=keep,
            password=password,
            )

        log += check(
            repository=repo,
            global_options=[],
            password=password,
            )

        if repo.startswith('b2:'):
          from .b2 import get_bucket
          info = get_bucket(repo[3:])
          sizes.append(0) #info['totalSize']
        else:
          from .utils import get_size
          sizes.append(get_size(repo))

        snaps += snapshots(
            repository=repo,
            global_options=[],
            hostname=hostname,
            password=password,
            )

      _send_success_email('backed-up', configs, log, sizes, snaps, hostname,
          email)

    except Exception as e:
      _send_error_email('back-up', configs, log, traceback.format_exc(),
          hostname, email)

    return log, sizes, snaps


  if period is None:
    logger.info('Scheduling backup job to run only once')
    return job() #run once
  else:
    logger.info('Scheduling backup job to run every day at %s', period)
    schedule.every().day.at(period).do(job)


  while True:
    schedule.run_pending()
    time.sleep(600)


def main(user_input=None):

  if user_input is not None:
    argv = user_input
  else:
    argv = sys.argv[1:]

  import docopt
  import socket
  import pkg_resources

  completions = dict(
      prog=os.path.basename(sys.argv[0]),
      version=pkg_resources.require('baker')[0].version,
      hostname=socket.gethostname(),
      )

  args = docopt.docopt(
      __doc__ % completions,
      argv=argv,
      version=completions['version'],
      )

  from .reporter import setup_logger
  logger = setup_logger('baker', args['--verbose'])

  from .restic import version as restic_version
  from .b2 import version as b2_version

  # log
  logger.info("Baker version %s (running on %s)",
      completions['version'], args['--hostname'])
  logger.info(" - %s", restic_version().split('\n')[0])
  logger.info(" - %s", b2_version().split('\n')[0])

  # do some commandline parsing
  config = dict([k.split('|') for k in args['<config>']])

  # check some config variables
  for dire, repo in config.items():
    if repo.startswith('b2:') and \
        (not args['--b2-account-id'] or not args['--b2-account-key']):
      raise RuntimeError('Specify --b2-account-id/key for repository `%s\'' % \
          repo)
    assert os.path.exists(dire)
    logger.info(" - (folder) %s -> %s (repo)", dire, repo)

  b2 = {}
  if args['--b2-account-id'] and args['--b2-account-key']:
    b2['id'] = args['--b2-account-id']
    b2['key'] = args['--b2-account-key']
    logger.info("B2 account id/key parameters provided")

  # parse e-mail details
  email = {}
  if args['--email']: #sending e-mails
    assert args['--email-sender'], 'You must set --email-sender to send ' \
        'e-mails'
    assert args['--email-receiver'], 'You must set --email-receiver to send' \
        'e-mails'
    assert args['--email-server'], 'You must set --email-server to send' \
        'e-mails'
    assert args['--email-port'], 'You must set --email-port to send' \
        'e-mails'
    assert args['--email-username'], 'You must set --email-username to send' \
        'e-mails'
    assert args['--email-password'], 'You must set --email-password to send' \
        'e-mails'
    email['sender'] = args['--email-sender']
    email['receiver'] = args['--email-sender']
    email['server'] = args['--email-server']
    email['port'] = args['--email-port']
    email['username'] = args['--email-username']
    email['password'] = args['--email-password']
  else:
    logger.info("Only logging e-mails, **not** sending anything")

  if args['init']:
    return init(config, args['<password>'], args['--overwrite'],
        args['--hostname'], b2)

  elif args['update']:

    keep_keys = ['last', 'hourly', 'daily', 'weekly', 'monthly', 'yearly']
    keep = dict(zip(keep_keys, [int(k) for k in args['--keep'].split('|')]))

    logger.info("Snapshot storage strategy (--keep flags):")
    for key, value in keep:
      logger.info(' - %s: %d', key.capitalize(), value)

    return update(config, args['<password>'], args['--hostname'], email, b2,
        keep, args['--run-daily'])

  return 0
